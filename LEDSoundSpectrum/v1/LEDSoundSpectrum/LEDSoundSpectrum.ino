/**
 * @file LEDSoundSpectrum.ino
 * @brief Main program to synchronize audio sampling, FFT computation, and
 * LED settings to affect a real-time visual spectrum analysis of ambient 
 * sound. Board, MCU, LED , and debug settings are found in config.h.
 * @details Program is organized as a FreeRTOS scheduler.
 * @copyright Chase Vara, 2024
 **/
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include <math.h>
#include <Arduino.h>
#include <Arduino_FreeRTOS.h>
#include <arm_math.h>
#include <FastLED.h>
#include "config.h"
#include "color_scales.h"
#include "audio_sampling.h"
#include "WS2812b_colorscale.h"

//// FreeRTOS data queues for for task synchronization /////////////////////////

QueueHandle_t Q_audio_data;
QueueHandle_t Q_fft_output;
QueueHandle_t Q_leds;
QueueHandle_t Q_palette;
QueueHandle_t Q_threshold;
QueueHandle_t Q_sample_rate;
QueueHandle_t Q_brightness;

//// FreeRTOS task routine prototypes //////////////////////////////////////////

/**
 * @fn Task_Setup
 * @brief Task function to setup the MCU/Board for FreeRTOS-scheduled operations
 * @details This task allocates data varaiables and their FreeRTOS queues for
 * data shared between subsequent tasks. Additionally, configures FastLED
 * library driver for WS2812b RGB LED strip, initially setting LEDs to off
*/
void Task_Setup(void *pvParameters);

/**
 * @fn Task_SampleAudio
 * @brief Samples audio data from analog input (input pin set in config.h).
 * @details The maximum sample rate is set in config.h. 
 * (USER FEATURE) The actual sample rate is set as a proportion of the max 
 * sample rate, which is set by an analog input (see config.h for input pin) 
*/
void Task_SampleAudio(void *pvParameters);

/**
 * @fn Task_FFT
 * @brief Performs an N-point FFT on the the audio sample generated by 
 * Task_SampleAudio (N set in config.h)
 * @details Computes FFT, removes the DC-component from the computed FFT 
 * and converts computed complex data into real magnitudes to send to 
 * Task_SetLEDs.
*/
void Task_FFT(void *pvParameters); 

/**
 * @fn Task_SetLEDs
 * @brief Maps magnitude data received from Task_FFT to WS2812b RGB LEDs, with
 * with LED indice value corresponding to location on the audio frequency 
 * spectrum for the Task_SampleAudio's set sample rate.
 * @details Color mapping is performed against the color scale defined in
 * config.h.
 * This task also affects two key user features:
 * (BRIGHTNESS): uses es an analog input to drive a brightness ratio which which
 * collectively adjusts the RGB color settings to uniformly control brightness
 * (THRESHOLD): Sets the threshold (as a percentrage of the max FFT component 
 * magnitude recived) below which FFT component magnitude data will be excluded.
 * The task also re-scales the valid data above the threshold to properly map to
 * to the full color-scale range. This has the effect of allowing the user to
 * dynamically adjust LEDs to show dominent frequency components of the sampled
 * audio.
*/
void Task_SetLEDs(void *pvParameters);

/**
 * @fn Task_Delay
 * @brief the purpose of this task is to aid memory management between deletion
 * of Task_SetLEDs and launching of Task_SampleAudio, whose simulaneous
 * operations could otherwise exceed the MCU's RAM limitations.
*/
void Task_Delay(void *pvParameters);

//// Main program //////////////////////////////////////////////////////////////

void setup() {
  if (__SERIAL_OUT__) {
    Serial.begin(115200);
    while (!Serial) {
      ; // wait for serial port to connect.
    }
  }

  #ifdef __RA4M1__
  R_MSTP->MSTPCRD &= ~(1 << 5); // cancel GPT module stop state
  #endif  // __RA4M1__

  // Set analog read resolution
  analogReadResolution(ANALOG_READ_RESOLUTION);

  // Launch setup task
  if(xTaskCreate(Task_Setup,
              "Setup Task",
              STACK_DEPTH_SETUP,
              NULL,
              PRIORITY_SETUP,
              NULL) != pdPASS) {
    Serial.println("Failed to create setup task");        
  }
  // Start scheduler
  vTaskStartScheduler() ;
}
void loop() {}


//// Task Definitions //////////////////////////////////////////////////////////

void Task_Setup(void *pvParameters) {
  // create audio data and FFT output queues
  Q_audio_data = xQueueCreate(1, sizeof(float*));
  Q_fft_output = xQueueCreate(1, sizeof(float*));

  float* audio_data = 
    (float*) pvPortMalloc(NUM_SAMPLES * sizeof(float));
  float* fft_output = 
    (float*) pvPortMalloc(NUM_SAMPLES * sizeof(float));

  if(xQueueSend(
    Q_audio_data, &audio_data, portMAX_DELAY) != pdPASS) {
    Serial.println("Failed to allocate Q_audio_data");
  }
  if(xQueueSend(
    Q_fft_output, &fft_output, portMAX_DELAY) != pdPASS) {
    Serial.println("Failed to allocate Q_fft_output");
  }

  // create LED data queues
  Q_leds = xQueueCreate(1, sizeof(CRGB*));
  Q_palette = xQueueCreate(1, sizeof(PALETTE_TYPE*));

  // led settings and color palette arrays
  CRGB* leds = (CRGB*) pvPortMalloc(NUM_LEDS * sizeof(CRGB));
  PALETTE_TYPE* color_palette_ptr =
    (PALETTE_TYPE*) pvPortMalloc(sizeof(PALETTE_TYPE));

  // initialize color palette array values
  int colorscale_hex[NUM_COLORS] = PALETTE_ARRAY;
  for (int i = 0; i < NUM_COLORS; i++) {
    (*color_palette_ptr)[i] = CRGB(colorscale_hex[i]);
  }

  // initialize LED array
  FastLED.addLeds<WS2812, PIN_LED_CONT, GRB>(leds, NUM_LEDS);

  // initialize LEDs to off
  for (int32_t i = 0; i < NUM_LEDS; i++) {
    leds[i] = SET_LEDS_OFF;
  }
  FastLED.show();
  
  // place in queues
  if(xQueueSend(
    Q_leds, &leds, portMAX_DELAY) != pdPASS) {
    Serial.println("Failed to allocate Q_leds");
  }
  if(xQueueSend(
    Q_palette, &color_palette_ptr, portMAX_DELAY) != pdPASS) {
    Serial.println("Failed to allocate Q_palette");
  }

  // create threshold data queue
  Q_threshold = xQueueCreate(1, sizeof(float));
  float threshold = 0.5 * (1 << ANALOG_READ_RESOLUTION);
  if(xQueueSend(Q_threshold, &threshold, portMAX_DELAY) != pdPASS) {
    Serial.println("Failed to allocate Q_threshold");
  }

  // create sampling rate data queue
  Q_sample_rate = xQueueCreate(1, sizeof(float*));
  float* f_sample = (float*) pvPortMalloc(sizeof(float*));
  if(xQueueSend(Q_sample_rate, &f_sample, portMAX_DELAY) != pdPASS) {
    Serial.println("Failed to allocate Q_sample_rate");
  }

  // create brightness data queue
  Q_brightness = xQueueCreate(1, sizeof(uint8_t*));
  uint8_t* brightness = (uint8_t*) pvPortMalloc(sizeof(uint8_t*));
  if(xQueueSend(Q_brightness, &brightness, portMAX_DELAY) != pdPASS) {
    Serial.println("Failed to allocate Q_brightness");
  }

  // launch audio samoling task
  bool created = false;
  created = xTaskCreate(Task_SampleAudio,
              "Audio Sampler Task",
              STACK_DEPTH_AUDIO,
              NULL,
              PRIORITY_AUDIO,
              NULL);
  if (!created) {
    Serial.println("Setup: Failed to create Audio Task");
  }     

  // Get the high water mark for debugging
  #ifdef __DEBUG_MEM_EVENT__
  UBaseType_t uxHighWaterMark = uxTaskGetStackHighWaterMark(NULL);
  Serial.print("SETUP: highwatermark (32-bit words): ");
  Serial.println(uxHighWaterMark);
  #endif. // __DEBUG_MEM_EVENT__

  vTaskDelete(NULL);
}

void Task_SampleAudio(void *pvParameters) {
  // Create local pointers to queued data variables
  float* audio_data;
  float* f_sample;
  float f_sample_setting;
  float f_sample_max = F_SAMPLE_MAX;
  float ratio = 0.0; // ratio of analog read to max read value

  // pointer toRA4M1 timer register struct
  R_GPT0_Type* timer_ptr;

  // Get sample rate setting
  xQueueReceive(Q_sample_rate, &f_sample, portMAX_DELAY);
  ratio = (float) analogRead(PIN_SAMPLE_RATE) / MAX_ADC_VAL;
  f_sample_setting = ratio * f_sample_max;
  *f_sample = f_sample_setting;
  if (xQueueSend(Q_sample_rate, &f_sample, portMAX_DELAY) != pdPASS) {
    Serial.println("Audio: Failed to send sample rate data.");
  }

  // Wait for use of audio data array
  xQueueReceive(Q_audio_data, &audio_data, portMAX_DELAY);

  // Take sample
  sample(audio_data, F_CPU, f_sample_setting, NUM_SAMPLES, PIN_AUDIO_IN);

  // print out Audio data
  if (__DEBUG_AUDIO__) {
    Serial.println("--------- AUDIO DATA BEGIN ---------\n");
    Serial.print(" Sample Rate: "); Serial.print(f_sample_setting);
    for (int i = 0; i < NUM_SAMPLES; i++) {
      Serial.print("\n  Audio raw sample #"); Serial.print(i);
      Serial.print("  ----  "); Serial.println(audio_data[i]);
    }
    Serial.println("---------- AUDIO DATA END ----------\n\n");
  }

  // Schedule FFT task
  int task_created = xTaskCreate(Task_FFT,
                                  "FFT Task",
                                  STACK_DEPTH_FFT,
                                  NULL,
                                  PRIORITY_FFT,
                                  NULL);

  // Send use of data array to successfully scheduled FFT task
  if (!task_created) {
    Serial.println("Audio Task: Failed to create FFT Task");
  }

  if(xQueueSend(
    Q_audio_data, &audio_data, portMAX_DELAY) != pdPASS) {
    Serial.println("Audio Task: Failed to send real audio data.");
  }

  // Get the high water mark for debugging
  #ifdef __DEBUG_MEM_EVENT__
  UBaseType_t uxHighWaterMark = uxTaskGetStackHighWaterMark(NULL);
  Serial.print("AUDIO: highwatermark (32-bit words): ");
  Serial.println(uxHighWaterMark);
  #endif  // __DEBUG_MEM_EVENT__

  vTaskDelete(NULL);
}

void Task_FFT(void *pvParameters) {
  float fft_intermediate[NUM_SAMPLES];  // buffer for data between FFT comp
                                        // output and complex-->magnitude comp
  float* audio_data;
  float* fft_output;
  float* f_sample;
  float energy_scaling_ratio;

  // Wait for use of audio data arrays, fft output array, and sample rate setting
  xQueueReceive(Q_audio_data, &audio_data, portMAX_DELAY);
  xQueueReceive(Q_fft_output, &fft_output, portMAX_DELAY);
  xQueueReceive(Q_sample_rate, &f_sample, portMAX_DELAY);

  if(xQueueSend(Q_sample_rate, &f_sample, portMAX_DELAY) != pdPASS) {
    Serial.println("Failed to allocate Q_sample_rate");
  }

  // set up fft
  arm_rfft_fast_instance_f32 fft;
  bool ifftFlag = 0;
  arm_rfft_fast_init_f32(&fft, NUM_SAMPLES);

  // perform computation
  arm_rfft_fast_f32(&fft, audio_data, fft_intermediate, ifftFlag);

  // get magnitude
  arm_cmplx_mag_f32(fft_intermediate, fft_output, NUM_SAMPLES_HALF);

  // scale data for Pareseval's theorum (signal energy representation in Freq domain) 
  if (SCALE_FFT_FOR_PARSEVAL) {
    // Calculate FFT scaling ratio from sample rate to maintain correct
    energy_scaling_ratio = 1.0 / *f_sample;

    // NOT scaling DC component since it will not be used (fft_output[0])
    for (int i = 1; i < NUM_SAMPLES_HALF; i++) {
      fft_output[0] *= energy_scaling_ratio;
    }
  }

  if (__DEBUG_FFT__) {
    Serial.println("--------- FFT OUTPUT BEGIN ---------\n");
    for (int i = 0; i < NUM_SAMPLES_HALF; i++) {
      Serial.print("\n  FFT Data #"); Serial.print(i);
      Serial.print("  ----  "); Serial.println(fft_output[i]);
    }
    Serial.println("---------- FFT OUTPUT END ----------\n\n");
  }

  // Schedule FFT LED setting task
  int task_created = xTaskCreate(Task_SetLEDs,
              "LED-Setting Task",
              STACK_DEPTH_LED,
              NULL,
              PRIORITY_LED,
              NULL);
  
  if (!task_created) {
    Serial.println("FFT Task: Failed to create LED Task");
  } 

  // Send audio and FFT output data to queue
  if(xQueueSend(
    Q_audio_data, &audio_data, portMAX_DELAY) != pdPASS) {
    Serial.println("FFT Task: Failed to send Q_audio_data.");
  }
  if(xQueueSend(
    Q_fft_output, &fft_output, portMAX_DELAY) != pdPASS) {
    Serial.println("FFT Task: Failed to send Q_fft_output.");
  }
  // Get the high water mark for debugging
  #ifdef __DEBUG_MEM_EVENT__
  UBaseType_t uxHighWaterMark = uxTaskGetStackHighWaterMark(NULL);
  Serial.print("FFT: highwatermark (32-bit words): ");
  Serial.println(uxHighWaterMark);
  #endif  // __DEBUG_MEM_EVENT__

  // Halt task
  vTaskDelete(NULL);
}

void Task_SetLEDs(void *pvParameters) {
  float* fft_output;
  float* threshold_val;
  float threshold_setting;
  float* brightness_val;
  float brightness_setting;
  float brightness_ratio;
  CRGB* led_settings;
  PALETTE_TYPE* color_palette_ptr;

  // Wait for use FFT output data
  xQueueReceive(Q_fft_output, &fft_output, portMAX_DELAY);

  // Wait for use of LED and color palette arrays
  xQueueReceive(Q_leds, &led_settings, portMAX_DELAY);
  xQueueReceive(Q_palette, &color_palette_ptr, portMAX_DELAY);

  // Wait for use of brightness data
  xQueueReceive(Q_brightness, &brightness_val, portMAX_DELAY);

  // Set brightness from analog input
  brightness_ratio = (float) analogRead(PIN_BRIGHTNESS_IN) / MAX_ADC_VAL;
  brightness_setting = brightness_ratio * MAX_FAST_LED_INDEX;
  *brightness_val = brightness_setting;

  // release use of brightness data
  if(xQueueSend(
    Q_brightness, &brightness_val, portMAX_DELAY) != pdPASS) {
    Serial.println("LED Task: Failed to send brightness data");
  }

  threshold_setting = (float) analogRead(PIN_THRESHOLD_IN) / MAX_ADC_VAL;

  // set LEDS
  LED_colorscale_set32(fft_output,
                       led_settings,
                       color_palette_ptr,
                       NUM_LEDS,
                       MAX_FAST_LED_INDEX,
                       DATA_LED_SCALE,
                       threshold_setting,
                       brightness_setting);

  // release use of LED and color palette arrays
  if(xQueueSend(
    Q_leds, &led_settings, portMAX_DELAY) != pdPASS) {
    Serial.println("LED Task: Failed to send Q_leds");
  }
  if(xQueueSend(
    Q_palette, &color_palette_ptr, portMAX_DELAY) != pdPASS) {
    Serial.println("LED: Failed to send Q_palette");
  }

  // release use of FFT output data
  if(xQueueSend(
    Q_fft_output, &fft_output, portMAX_DELAY) != pdPASS) {
    Serial.println("LED Task: Failed to send Q_fft_output.");
  }

  #ifdef __USE_DELAY__
  // Initialize delay task
  bool created = xTaskCreate(Task_Delay,
              "Delay Task",
              STACK_DEPTH_DELAY,
              NULL,
              PRIORITY_DELAY,
              NULL);
  if (!created) {
    Serial.println("LED Task: Failed to create Delay Task");
  }
  #endif  // __USE_DELAY__

  #ifndef __USE_DELAY__
  // Initialize delay task

  // initialize audio task and halt
  bool created = xTaskCreate(Task_SampleAudio,
              "Audio Sampler Task",
              STACK_DEPTH_AUDIO,
              NULL,
              PRIORITY_AUDIO,
              NULL);
  if (!created) {
    Serial.println("LED Task: Failed to create Audio Task");
  }
  #endif  // __USE_DELAY__

  // Get the high water mark for debugging
  #ifdef __DEBUG_MEM_EVENT__
  UBaseType_t uxHighWaterMark = uxTaskGetStackHighWaterMark(NULL);
  Serial.print("LED: highwatermark (32-bit words): ");
  Serial.println(uxHighWaterMark);
  #endif  // __DEBUG_MEM_EVENT__

  vTaskDelete(NULL);
}

void Task_Delay(void *pvParameters) {
  // delay value variable
  uint32_t delay_setting = DEFAULT_DELAY_MILLIS;

  // Invoke schedule iteration delay
  vTaskDelay((float) delay_setting / portTICK_PERIOD_MS);

  // initialize audio task and halt
  bool created = xTaskCreate(Task_SampleAudio,
              "Audio Sampler Task",
              STACK_DEPTH_AUDIO,
              NULL,
              PRIORITY_AUDIO,
              NULL);
  if (!created) {
    Serial.println("Delay Task: Failed to create Audio Task");
  }

  // Get the high water mark for debugging
  #ifdef __DEBUG_MEM_EVENT__
  UBaseType_t uxHighWaterMark = uxTaskGetStackHighWaterMark(NULL);
  Serial.print("DELAY: highwatermark (32-bit words): ");
  Serial.println(uxHighWaterMark);
  #endif  // __DEBUG_MEM_EVENT__

  vTaskDelete(NULL);
}
